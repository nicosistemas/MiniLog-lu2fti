# Importamos las librerías necesarias
from flask import Flask, render_template, request, redirect, send_file
import csv
import os
from datetime import datetime, timezone

# Inicializamos la aplicación Flask
app = Flask(__name__)

# Variables globales para mantener el último modo y frecuencia registrados
last_mode = ''
last_frequency = ''

# ================================
# Funciones de gestión del operador
# ================================

def save_operator_id(op_id):
    """Guarda el ID del operador en un archivo de texto."""
    with open('operator_id.txt', 'w') as f:
        f.write(op_id)

def load_operator_id():
    """Carga el ID del operador desde el archivo de texto, o retorna uno por defecto."""
    if os.path.exists('operator_id.txt'):
        with open('operator_id.txt', 'r') as f:
            return f.read().strip()
    else:
        return 'LU2FTI'  # Valor por defecto si no existe el archivo

# Cargar el operator_id al iniciar la app
operator_id = load_operator_id()

# ================================
# Funciones auxiliares
# ================================

def get_band(frequency):
    """Determina la banda de frecuencia basada en la frecuencia ingresada."""
    try:
        frequency = float(frequency)
    except ValueError:
        return "UNKNOWN"

    # Rango de frecuencias para cada banda
    if 1.8 <= frequency < 2.0:
        return "160m"
    elif 3.5 <= frequency < 4.0:
        return "80m"
    elif 5.0 <= frequency < 5.5:
        return "60m"
    elif 7.0 <= frequency < 7.3:
        return "40m"
    elif 10.1 <= frequency < 10.15:
        return "30m"
    elif 14.0 <= frequency < 14.35:
        return "20m"
    elif 18.068 <= frequency < 18.168:
        return "17m"
    elif 21.0 <= frequency < 21.45:
        return "15m"
    elif 24.89 <= frequency < 24.99:
        return "12m"
    elif 28.0 <= frequency < 29.7:
        return "10m"
    elif 50.0 <= frequency < 54.0:
        return "6m"
    elif 144.0 <= frequency < 148.0:
        return "2m"
    elif 430.0 <= frequency < 450.0:
        return "70cm"
    else:
        return "UNKNOWN"

# ================================
# Rutas de la aplicación
# ================================

@app.route('/', methods=['GET', 'POST'])
def index():
    """Ruta principal: permite registrar contactos y visualizar el historial."""
    global last_mode, last_frequency, operator_id

    if request.method == 'POST':
        # Actualizamos el ID del operador si fue cambiado
        if 'operator_id' in request.form and request.form['operator_id']:
            operator_id = request.form['operator_id']
            save_operator_id(operator_id)

        # Capturamos los datos del formulario
        contact_id = request.form['id']
        mode = request.form['mode']
        frequency = request.form['frequency']
        extra = request.form['extra']
        date = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')

        # Actualizamos las últimas variables
        last_mode = mode
        last_frequency = frequency

        # Guardamos el contacto en el CSV
        with open('contacts.csv', 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([date, contact_id, mode, frequency, extra, operator_id])
        
        return redirect('/')

    # Leemos los contactos existentes
    contacts = []
    if os.path.exists('contacts.csv'):
        with open('contacts.csv', newline='') as csvfile:
            reader = csv.reader(csvfile)
            contacts = list(reader)

    # Renderizamos el HTML
    return render_template('index.html', contacts=contacts, last_mode=last_mode, last_frequency=last_frequency, operator_id=operator_id)

@app.route('/export')
def export():
    """Ruta para exportar los contactos en formato ADIF."""
    global operator_id

    # Leemos los contactos existentes
    contacts = []
    if os.path.exists('contacts.csv'):
        with open('contacts.csv', newline='') as csvfile:
            reader = csv.reader(csvfile)
            contacts = list(reader)

    # Si no hay operator_id definido
    if not operator_id:
        operator_id = 'UNKNOWN'

    current_time = datetime.now().strftime("%Y%m%d-%H%M%S")
    filename = f"contacts-{current_time}.adi"

    # Generamos el contenido del archivo ADIF
    adi_content = "Generated by MiniLog by LU2FTI\n"
    for c in contacts:
        if len(c) < 6:
            print(f"Skipping incomplete contact entry: {c}")
            continue

        band = get_band(c[3])
        extra = c[4] if len(c) > 4 else ''
        qso_date = c[0].split()[0].replace("-", "")

        try:
            time_on = datetime.strptime(c[0], '%Y-%m-%d %H:%M:%S').strftime('%H%M%S')
        except ValueError:
            time_on = '000000'

        adi_content += f"<CALLSIGN_STATION:{len(operator_id)}>{operator_id} <CALL:{len(c[1])}>{c[1]} <QSO_DATE:{len(qso_date)}>{qso_date} <TIME_ON:{len(time_on)}>{time_on} <BAND:{len(band)}>{band} <FREQ:{len(c[3])}>{c[3]} <MODE:{len(c[2])}>{c[2]} <EXTRA:{len(extra)}>{extra}\n"

    # Si no hay contactos, informamos
    if adi_content.strip() == "Generated by MiniLog by LU2FTI":
        return "No hay contactos para exportar"

    # Escribimos el archivo
    try:
        with open(filename, 'w') as f:
            f.write(adi_content)
    except Exception as e:
        return f"Error al escribir el archivo ADIF: {e}"

    # Enviamos el archivo al usuario
    return send_file(filename, as_attachment=True)

# ================================
# Arranque de la aplicación
# ================================

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)
