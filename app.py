from flask import Flask, render_template, request, redirect, send_file
import csv
import os
from datetime import datetime, timezone

app = Flask(__name__)

# Variables para mantener el último modo y frecuencia
last_mode = ''
last_frequency = ''
operator_id = 'LU2FTI'  # ID del operador inicial por defecto

# Función para obtener la banda según la frecuencia
def get_band(frequency):
    """
    Determina la banda según la frecuencia ingresada.
    """
    try:
        frequency = float(frequency)
    except ValueError:
        return "UNKNOWN"

    if 1.8 <= frequency < 2.0:
        return "160m"
    elif 3.5 <= frequency < 4.0:
        return "80m"
    elif 5.0 <= frequency < 5.5:
        return "60m"
    elif 7.0 <= frequency < 7.3:
        return "40m"
    elif 10.1 <= frequency < 10.15:
        return "30m"
    elif 14.0 <= frequency < 14.35:
        return "20m"
    elif 18.068 <= frequency < 18.168:
        return "17m"
    elif 21.0 <= frequency < 21.45:
        return "15m"
    elif 24.89 <= frequency < 24.99:
        return "12m"
    elif 28.0 <= frequency < 29.7:
        return "10m"
    elif 50.0 <= frequency < 54.0:
        return "6m"
    elif 144.0 <= frequency < 148.0:
        return "2m"
    elif 430.0 <= frequency < 450.0:
        return "70cm"
    else:
        return "UNKNOWN"

@app.route('/', methods=['GET', 'POST'])
def index():
    global last_mode, last_frequency, operator_id
    if request.method == 'POST':
        # Si el campo de operador es enviado, actualizamos el ID del operador
        if 'operator_id' in request.form and request.form['operator_id']:
            operator_id = request.form['operator_id']

        contact_id = request.form['id']
        mode = request.form['mode']
        frequency = request.form['frequency']
        extra = request.form['extra']
        date = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')

        # Guardar los últimos modo y frecuencia
        last_mode = mode
        last_frequency = frequency

        with open('contacts.csv', 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([date, contact_id, mode, frequency, extra, operator_id])
        return redirect('/')

    contacts = []
    if os.path.exists('contacts.csv'):
        with open('contacts.csv', newline='') as csvfile:
            reader = csv.reader(csvfile)
            contacts = list(reader)

    return render_template('index.html', contacts=contacts, last_mode=last_mode, last_frequency=last_frequency, operator_id=operator_id)

@app.route('/export')
def export():
    global operator_id

    contacts = []
    if os.path.exists('contacts.csv'):
        with open('contacts.csv', newline='') as csvfile:
            reader = csv.reader(csvfile)
            contacts = list(reader)

    # Si no se ha definido un operador, usar un valor predeterminado
    if not operator_id:
        operator_id = 'UNKNOWN'

    # Obtener la fecha y hora actual para nombrar el archivo
    current_time = datetime.now().strftime("%Y%m%d-%H%M%S")
    filename = f"contacts-{current_time}.adi"  # Crear el nombre del archivo con la hora

    # Creamos el contenido para el archivo ADIF
    adi_content = "Generated by MiniLog by LU2FTI\n"
    for c in contacts:
        # Verificamos si la fila tiene al menos 6 elementos antes de procesar
        if len(c) < 6:
            print(f"Skipping incomplete contact entry: {c}")
            continue  # Si la fila no tiene suficientes columnas, la omitimos

        # Utilizamos la función get_band para obtener la banda según la frecuencia
        band = get_band(c[3])  # c[3] es la frecuencia

        # Verificamos si hay un campo extra
        extra = c[4] if len(c) > 4 else ''

        # Fecha y hora en formato ADIF
        # Obtenemos solo la parte de la fecha en formato YYYYMMDD
        qso_date = c[0].split()[0].replace("-", "")  # Extraemos la fecha en formato YYYYMMDD

        # Obtenemos solo la parte de la hora en formato HHMMSS
        try:
            time_on = datetime.strptime(c[0], '%Y-%m-%d %H:%M:%S').strftime('%H%M%S')
        except ValueError:
            time_on = '000000'  # Si la fecha no tiene el formato esperado, usamos '000000'

        # Generamos la entrada ADIF
        adi_content += f"<CALLSIGN_STATION:{len(operator_id)}>{operator_id} <CALL:{len(c[1])}>{c[1]} <QSO_DATE:{len(qso_date)}>{qso_date} <TIME_ON:{len(time_on)}>{time_on} <BAND:{len(band)}>{band} <FREQ:{len(c[3])}>{c[3]} <MODE:{len(c[2])}>{c[2]} <EXTRA:{len(extra)}>{extra}\n"

    # Verificamos que se haya generado contenido para exportar
    if adi_content.strip() == "Generated by MiniLog by LU2FTI":
        return "No hay contactos para exportar"

    # Guardamos el archivo ADIF en el directorio actual con el nombre que incluye la hora
    try:
        with open(filename, 'w') as f:
            f.write(adi_content)
    except Exception as e:
        return f"Error al escribir el archivo ADIF: {e}"

    # Regresamos el archivo generado para su descarga
    return send_file(filename, as_attachment=True)

if __name__ == '__main__':
#    app.run(debug=True)
    app.run(host='0.0.0.0', debug=True)
